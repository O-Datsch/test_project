<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raketenstart</title>
    <!-- Tailwind CSS für einfaches Styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Verhindert Scrollbalken */
            background-color: #000000; /* Schwarzer Hintergrund für den Weltraum */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100vh; /* Canvas füllt jetzt die ganze Höhe */
            background-color: #000000; /* Schwarzer Hintergrund für den Weltraum */
            cursor: grab; /* Zeigt an, dass der Canvas greifbar ist */
        }
        canvas:active {
            cursor: grabbing; /* Zeigt an, dass der Canvas gegriffen wird */
        }
        #instructions, #rocketPositionDisplay, #cameraHeightDisplay, #positionControl, #cloudHeightControl { /* Hinzufügen aller UI-Elemente */
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            color: #ffffff;
            font-size: 1.1rem;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 8px;
            text-align: center;
            z-index: 10;
        }
        #instructions {
            top: 20px;
            pointer-events: none; /* Macht das Element klick-durchlässig, damit es die Interaktion mit der 3D-Szene nicht stört */
        }
        #rocketPositionDisplay {
            top: 80px; /* Unter den Anweisungen platzieren */
            font-size: 1.3rem;
            font-weight: 700;
            pointer-events: none; /* Macht das Element klick-durchlässig */
        }
        #cameraHeightDisplay { /* Styling für die Kamera-Höhenanzeige */
            top: 140px; /* Unter der Raketenhöhenanzeige platzieren */
            font-size: 1.1rem;
            pointer-events: none; /* Macht das Element klick-durchlässig */
        }
        #positionControl {
            top: 200px; /* Unter den anderen Anzeigen platzieren */
            pointer-events: all; /* Ermöglicht Interaktion mit dem Schieberegler */
        }
        #cloudHeightControl { /* Position für den neuen Wolken-Schieberegler */
            top: 280px; /* Unter dem Raketen-Schieberegler platzieren */
            pointer-events: all;
        }
        #yPositionSlider, #cloudHeightSlider {
            width: 250px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <!-- Anweisungen für den Benutzer -->
    <div id="instructions">
        Drücke und halte die Taste "0" (Null) auf deiner Tastatur, um die Rakete zu beschleunigen!
        <br> (Klicke und ziehe mit der Maus, um die Kamera zu schwenken. Scrolle mit dem Mausrad zum Zoomen!)
    </div>
    <!-- Anzeige der Raketenhöhe -->
    <div id="rocketPositionDisplay">
        Raketenhöhe: 0.00 Meter
    </div>
    <!-- Anzeige der Kamerahöhe -->
    <div id="cameraHeightDisplay"> 
        Kamerahöhe: 0.00 Meter
    </div>
    <!-- Steuerelemente für die Raketenposition -->
    <div id="positionControl">
        Raketenposition Y: <span id="yPositionValue">0.00</span> Meter
        <br>
        <!-- Schieberegler für die Y-Position der Rakete -->
        <input type="range" id="yPositionSlider" min="0" max="400000000" value="0" step="100"> 
    </div>
    <!-- Neuer Steuerelement für die Wolkenhöhe -->
    <div id="cloudHeightControl">
        Wolkenhöhe über Erde: <span id="cloudHeightValue">0.00</span> Meter
        <br>
        <input type="range" id="cloudHeightSlider" min="0" max="400000" value="0" step="100"> 
    </div>

    <!-- Three.js Bibliothek -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls für Kamera-Interaktion - DEAKTIVIERT -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script> -->

    <script type="module">
        // Globale Variablen für Firebase (werden vom Canvas-Environment bereitgestellt)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        // FIX: initialAuthToken korrekt initialisieren, indem es sich auf __initial_auth_token bezieht
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Szene, Kamera, Renderer initialisieren
        let scene, camera, renderer;
        let rocket, earth, moon, clouds, stars, sun;
        let thrustActive = false;
        let rocketPositionDisplay;
        let cameraHeightDisplay;
        let yPositionSlider;
        let yPositionValueDisplay;
        // Neue Variablen für den Wolken-Schieberegler
        let cloudHeightSlider;
        let cloudHeightValueDisplay;
        let currentCloudHeightAboveSurface; // Dynamische Höhe der Wolken über der Oberfläche

        // Raketen-Physik-Variablen (Einheiten: Meter)
        const GRAVITY = -9.81; // Gravitation in m/s^2
        const THRUST = 40.0;  // Schubkraft in m/s^2
        let rocketVelocity = new THREE.Vector3(0, 0, 0);
        let rocketPosition = new THREE.Vector3(0, 0, 0);

        // Erde und Mond Dimensionen (Einheiten: Meter)
        const EARTH_RADIUS = 6356500; // Erde: 6356.5 km = 6356500 Meter
        const MOON_RADIUS = 1737000;   // Mond: 1737 km = 1737000 Meter
        const MOON_Y_OFFSET_FROM_ROCKET_START = 363300000; // Mondabstand: 363300 km = 363300000 Meter
        const STARFIELD_RADIUS = 30000000; // Sternenkuppel-Radius: 30000 km = 30000000 Meter
        const SUN_RADIUS = 696342000; // Sonne: 696342 km = 696342000 Meter

        // Konstanten für die Position der Sonne (Einheiten: Meter)
        const SUN_POS_X = 150000000000; // ca. 150 Mio km (durchschnittlicher Abstand Erde-Sonne)
        const SUN_POS_Y = 100000000000;
        const SUN_POS_Z = 0;

        // Raketendimensionen (Einheiten: Meter)
        const ROCKET_BODY_HEIGHT = 60; // 60 Meter
        const ROCKET_BODY_RADIUS_TOP = 6; // 6 Meter
        const ROCKET_BODY_RADIUS_BOTTOM = 12; // 12 Meter
        const ROCKET_NOSE_HEIGHT = 24; // 24 Meter
        const ROCKET_NOSE_RADIUS = 12; // 12 Meter
        const ROCKET_FIN_LENGTH = 21; // 21 Meter
        const ROCKET_FIN_HEIGHT = 36; // 36 Meter
        const ROCKET_FIN_OFFSET = 12; // 12 Meter
        const ROCKET_HALF_BODY_HEIGHT = ROCKET_BODY_HEIGHT / 2; // Automatisch 30 Meter

        // Kamera-Steuerungsparameter für manuelle Verfolgung
        let cameraDistance;
        let currentPanAngle = Math.PI;
        let currentTiltAngle = Math.PI / 2.2;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        const PAN_SENSITIVITY = 0.005;
        const TILT_SENSITIVITY = 0.005;
        const ZOOM_MULTIPLIER_FACTOR = 0.0005; 

        // Haus Dimensionen und Stadt Parameter (Einheiten: Meter)
        const HOUSE_HEIGHT = 60;
        const HOUSE_WIDTH = 45;
        const HOUSE_DEPTH = 45;
        const ROOF_HEIGHT = 21;
        const ROOF_BASE_RADIUS = HOUSE_WIDTH / 2 * 1.2;

        const CITY_RADIUS_MIN = 150; // Häuser beginnen 150 Meter von der Rakete entfernt
        const CITY_RADIUS_MAX = 450; // Häuser erstrecken sich bis zu 450 Meter
        const NUM_HOUSES = 150;

        // Geografische Koordinaten für Deutschland (ungefähr Leichlingen, NRW)
        const GERMANY_LATITUDE = 51.028;
        const GERMANY_LONGITUDE = -75.009;

        // Flag, um zu erkennen, ob der Schieberegler aktiv manipuliert wird
        let sliderManualControl = false;

        // Wolken-Partikel-Konstanten
        const NUM_CLOUD_PARTICLES = 100000;
        const CLOUD_PARTICLE_SIZE = 50000;
        const CLOUD_THICKNESS_VARIATION = EARTH_RADIUS * 0.005; // Dicke der Wolkenschicht

        // Sterne-Konstanten
        const NUM_STARS = 10000;

        window.onload = function () {
            init();
            animate();
        };

        // Funktion zum Aktualisieren der Wolkengeometrie basierend auf der aktuellen Höhe
        function updateCloudsGeometry() {
            const cloudPositions = clouds.geometry.attributes.position.array;
            
            // Berechne den mittleren Radius für die Wolkenschicht vom Erdmittelpunkt aus
            // currentCloudHeightAboveSurface ist die Höhe der Wolken über der Erdoberfläche (Y=0)
            const meanCloudRadiusFromEarthCenter = EARTH_RADIUS + currentCloudHeightAboveSurface;

            for (let i = 0; i < NUM_CLOUD_PARTICLES; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1); // Für gleichmäßige Verteilung auf einer Kugel

                // Berechne den Radius für dieses Partikel, variierend um den mittleren Wolkenradius
                const particleRadiusFromEarthCenter = meanCloudRadiusFromEarthCenter + (Math.random() - 0.5) * CLOUD_THICKNESS_VARIATION;

                // Konvertiere sphärische in kartesische Koordinaten (relativ zum Ursprung des Wolkenobjekts, welches sich im Erdmittelpunkt befindet)
                const x = particleRadiusFromEarthCenter * Math.sin(phi) * Math.cos(theta);
                const y = particleRadiusFromEarthCenter * Math.cos(phi);
                const z = particleRadiusFromEarthCenter * Math.sin(phi) * Math.sin(theta);

                cloudPositions[i * 3] = x;
                cloudPositions[i * 3 + 1] = y;
                cloudPositions[i * 3 + 2] = z;
            }
            clouds.geometry.attributes.position.needsUpdate = true; // Signalisiere Three.js, dass die Positionen aktualisiert wurden
        }


        function init() {
            // Szene erstellen
            scene = new THREE.Scene();

            // Kamera erstellen (PerspectiveCamera: fov, aspect, near, far)
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 300000000);
            
            // Referenz auf die UI-Elemente
            rocketPositionDisplay = document.getElementById('rocketPositionDisplay');
            cameraHeightDisplay = document.getElementById('cameraHeightDisplay');
            yPositionSlider = document.getElementById('yPositionSlider');
            yPositionValueDisplay = document.getElementById('yPositionValue');
            cloudHeightSlider = document.getElementById('cloudHeightSlider');
            cloudHeightValueDisplay = document.getElementById('cloudHeightValue');

            // Setze die Slider-Bereiche basierend auf der Szenenskalierung
            yPositionSlider.min = (ROCKET_HALF_BODY_HEIGHT).toFixed(2);
            yPositionSlider.max = (MOON_Y_OFFSET_FROM_ROCKET_START + MOON_RADIUS * 2).toFixed(2);
            yPositionSlider.value = (ROCKET_HALF_BODY_HEIGHT).toFixed(2); // Rakete startet auf dem Boden
            yPositionValueDisplay.textContent = (parseFloat(yPositionSlider.value) - ROCKET_HALF_BODY_HEIGHT).toFixed(2);


            // Initialer Raketenposition auf den Slider-Wert setzen
            rocketPosition.set(0, parseFloat(yPositionSlider.value), 0);

            // Initialer Kameraabstand basierend auf der initialen Raketenposition
            cameraDistance = ROCKET_BODY_HEIGHT * 10; // 10 mal die Raketenhöhe für eine gute Startansicht

            // Kamera-Startposition berechnen basierend auf Sphärenkoordinaten
            camera.position.x = rocketPosition.x + cameraDistance * Math.sin(currentTiltAngle) * Math.sin(currentPanAngle);
            camera.position.y = rocketPosition.y + cameraDistance * Math.cos(currentTiltAngle);
            camera.position.z = rocketPosition.z + cameraDistance * Math.sin(currentTiltAngle) * Math.cos(currentPanAngle);
            camera.lookAt(rocketPosition);


            // Renderer erstellen
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Manuelle Steuerung: Event-Listener für Maus
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            renderer.domElement.addEventListener('wheel', onMouseWheel, false);

            // Event-Listener für den Raketen-Schieberegler
            yPositionSlider.addEventListener('input', function() {
                sliderManualControl = true;
                rocketPosition.y = parseFloat(this.value);
                rocketVelocity.y = 0;
                yPositionValueDisplay.textContent = (parseFloat(this.value) - ROCKET_HALF_BODY_HEIGHT).toFixed(2);
            });
            yPositionSlider.addEventListener('change', function() {
                sliderManualControl = false;
            });

            // Setze initialen Wert und Bereich für den Wolken-Schieberegler (Einheiten: Meter)
            currentCloudHeightAboveSurface = 10000; // 10 km = 10000 Meter über der Erdoberfläche
            cloudHeightSlider.min = 100; // Mindesthöhe 100 Meter
            cloudHeightSlider.max = 100000; // Maximale Höhe 100 km = 100000 Meter
            cloudHeightSlider.value = currentCloudHeightAboveSurface;
            cloudHeightValueDisplay.textContent = currentCloudHeightAboveSurface.toFixed(2);

            // Event-Listener für den Wolken-Schieberegler
            cloudHeightSlider.addEventListener('input', function() {
                currentCloudHeightAboveSurface = parseFloat(this.value);
                updateCloudsGeometry(); // Wolkengeometrie aktualisieren
                cloudHeightValueDisplay.textContent = currentCloudHeightAboveSurface.toFixed(2);
            });


            // Beleuchtung hinzufügen
            const sunLight = new THREE.DirectionalLight(0xffffff, 2);
            sunLight.position.set(SUN_POS_X, SUN_POS_Y, SUN_POS_Z);
            sunLight.target.position.set(0, 0, 0);
            scene.add(sunLight);
            scene.add(sunLight.target);

            const ambientLight = new THREE.AmbientLight(0x404040, 1);
            scene.add(ambientLight);

            // Sonne als Objekt hinzufügen
            const sunGeometry = new THREE.SphereGeometry(SUN_RADIUS, 16, 16);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(SUN_POS_X, SUN_POS_Y, SUN_POS_Z);
            scene.add(sun);


            // Erde erstellen
            const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 512, 512);
            const textureLoader = new THREE.TextureLoader();

            const earthDiffuseMap = textureLoader.load(
                'https://raw.githack.com/mrdoob/three.js/dev/examples/textures/planets/earth_atmos_2048.jpg', undefined, undefined, (err) => console.error('Fehler beim Laden der Erdoberflächen-Textur:', err)
            );
            const earthNormalMap = textureLoader.load(
                'https://raw.githack.com/mrdoob/three.js/dev/examples/textures/planets/earth_normal_2048.jpg', undefined, undefined, (err) => console.error('Fehler beim Laden der Erd-Normalmap:', err)
            );
            const earthSpecularMap = textureLoader.load(
                'https://raw.githack.com/mrdoob/three.js/dev/examples/textures/planets/earth_specular_2048.jpg', undefined, undefined, (err) => console.error('Fehler beim Laden der Erd-Specularmap:', err)
            );
            const earthDisplacementMap = textureLoader.load(
                'https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/World_Elevation_Map_8_bit_%28World_Height_map%29_%28alterative_version%29.png/2560px-World_Elevation_Map_8_bit_%28World_Height_map%29_%28alterative_version%29.png', undefined, undefined, (err) => console.error('Fehler beim Laden der Erd-Displacementmap:', err)
            );

            const earthMaterial = new THREE.MeshPhongMaterial({
                map: earthDiffuseMap,
                normalMap: earthNormalMap,
                specularMap: earthSpecularMap,
                shininess: 20,
                color: 0xffffff
            });
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            earth.position.y = -EARTH_RADIUS; // Erde so positionieren, dass ihre Oberfläche bei Y=0 ist

            const latRad = GERMANY_LATITUDE * (Math.PI / 180);
            const lonRad = GERMANY_LONGITUDE * (Math.PI / 180);

            earth.rotation.y = -lonRad;
            earth.rotation.x = (Math.PI / 2) - latRad;

            scene.add(earth);

            // Wolken als Partikelsystem erstellen (Initialerstellung)
            const cloudsGeometry = new THREE.BufferGeometry();
            cloudsGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(NUM_CLOUD_PARTICLES * 3), 3));

            const cloudSpriteTexture = textureLoader.load(
                'https://raw.githack.com/mrdoob/three.js/dev/examples/textures/sprites/disc.png', // Bessere Textur für Wolken
                undefined,
                undefined,
                (err) => console.error('Fehler beim Laden der Wolken-Sprite-Textur:', err)
            );

            const cloudsMaterial = new THREE.PointsMaterial({
                size: CLOUD_PARTICLE_SIZE,
                sizeAttenuation: true,
                map: cloudSpriteTexture,
                alphaTest: 0.0, // Kein AlphaTest, da die Textur bereits transparente Bereiche hat
                transparent: true,
                blending: THREE.NormalBlending,
                depthWrite: false,
                color: 0xFFFFFF, // Wolken sind jetzt weiß
                opacity: 1.0 // Textur-Alpha wird verwendet, volle Opazität
            });

            clouds = new THREE.Points(cloudsGeometry, cloudsMaterial);
            clouds.position.y = -EARTH_RADIUS; // Wolkenmittelpunkt im Erdmittelpunkt
            clouds.rotation.copy(earth.rotation);
            scene.add(clouds);

            // Initialen Wolkenpositionen generieren
            updateCloudsGeometry();


            // Sterne erstellen (THREE.Points)
            const starPositions = new Float32Array(NUM_STARS * 3);
            const starColors = new Float32Array(NUM_STARS * 3); 

            for (let i = 0; i < NUM_STARS; i++) {
                const x = (Math.random() - 0.5) * 2 * STARFIELD_RADIUS;
                const y = (Math.random() - 0.5) * 2 * STARFIELD_RADIUS;
                const z = (Math.random() - 0.5) * 2 * STARFIELD_RADIUS;

                const distance = Math.sqrt(x*x + y*y + z*z);
                if (distance > STARFIELD_RADIUS) {
                    const scale = STARFIELD_RADIUS / distance;
                    starPositions[i * 3] = x * scale;
                    starPositions[i * 3 + 1] = y * scale;
                    starPositions[i * 3 + 2] = z * scale;
                } else {
                    starPositions[i * 3] = x;
                    starPositions[i * 3 + 1] = y;
                    starPositions[i * 3 + 2] = z;
                }

                const color = new THREE.Color();
                color.setHSL(Math.random(), 1.0, 0.5 + Math.random() * 0.5);
                starColors[i * 3] = color.r;
                starColors[i * 3 + 1] = color.g;
                starColors[i * 3 + 2] = color.b;
            }

            const starsGeometry = new THREE.BufferGeometry();
            starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starsGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));

            const starMaterial = new THREE.PointsMaterial({
                size: 100000,
                sizeAttenuation: true,
                map: textureLoader.load('https://raw.githack.com/mrdoob/three.js/dev/examples/textures/sprites/disc.png'),
                alphaTest: 0.5,
                transparent: true,
                blending: THREE.AdditiveBlending,
                vertexColors: true
            });

            stars = new THREE.Points(starsGeometry, starMaterial);
            scene.add(stars);


            // Mond erstellen
            const moonGeometry = new THREE.SphereGeometry(MOON_RADIUS, 32, 32);
            const moonTexture = textureLoader.load(
                'https://raw.githack.com/mrdoob/three.js/dev/examples/textures/planets/moon_1024.jpg', undefined, undefined, (err) => console.error('Fehler beim Laden der Mondtextur:', err)
            );
            const moonMaterial = new THREE.MeshLambertMaterial({ map: moonTexture });
            moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.position.set(-10000000, MOON_Y_OFFSET_FROM_ROCKET_START, 100000000);
            scene.add(moon);

            // Rakete erstellen
            const rocketBodyGeometry = new THREE.CylinderGeometry(ROCKET_BODY_RADIUS_TOP, ROCKET_BODY_RADIUS_BOTTOM, ROCKET_BODY_HEIGHT, 32);
            const rocketMaterial = new THREE.MeshLambertMaterial({ color: 0xdddddd });
            const rocketBody = new THREE.Mesh(rocketBodyGeometry, rocketMaterial);

            const rocketNoseGeometry = new THREE.ConeGeometry(ROCKET_NOSE_RADIUS, ROCKET_NOSE_HEIGHT, 32);
            const rocketNoseMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            const rocketNose = new THREE.Mesh(rocketNoseGeometry, rocketNoseMaterial);
            rocketNose.position.y = ROCKET_HALF_BODY_HEIGHT + (ROCKET_NOSE_HEIGHT / 2);

            const finShape = new THREE.Shape();
            finShape.moveTo(0, 0);
            finShape.lineTo(ROCKET_FIN_LENGTH, 0);
            finShape.lineTo(ROCKET_FIN_LENGTH / 2, ROCKET_FIN_HEIGHT);
            finShape.lineTo(0, 0);
            const finGeometry = new THREE.ShapeGeometry(finShape);
            const finMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });

            const fin1 = new THREE.Mesh(finGeometry, finMaterial);
            fin1.rotation.y = Math.PI / 2;
            fin1.position.set(0, -ROCKET_HALF_BODY_HEIGHT, ROCKET_FIN_OFFSET);

            const fin2 = new THREE.Mesh(finGeometry, finMaterial);
            fin2.rotation.y = -Math.PI / 2;
            fin2.position.set(0, -ROCKET_HALF_BODY_HEIGHT, -ROCKET_FIN_OFFSET);

            const fin3 = new THREE.Mesh(finGeometry, finMaterial);
            fin3.position.set(ROCKET_FIN_OFFSET, -ROCKET_HALF_BODY_HEIGHT, 0);

            const fin4 = new THREE.Mesh(finGeometry, finMaterial);
            fin4.position.set(-ROCKET_FIN_OFFSET, -ROCKET_HALF_BODY_HEIGHT, 0);

            rocket = new THREE.Group();
            rocket.add(rocketBody);
            rocket.add(rocketNose);
            rocket.add(fin1);
            rocket.add(fin2);
            rocket.add(fin3);
            rocket.add(fin4);

            rocket.position.copy(rocketPosition);
            scene.add(rocket);


            // Funktion zum Erstellen eines Hauses
            function createHouse(x, y, z) {
                const houseGroup = new THREE.Group();
                const bodyGeometry = new THREE.BoxGeometry(HOUSE_WIDTH, HOUSE_HEIGHT, HOUSE_DEPTH);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = HOUSE_HEIGHT / 2;
                houseGroup.add(body);

                const roofGeometry = new THREE.ConeGeometry(ROOF_BASE_RADIUS, ROOF_HEIGHT, 4);
                const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x008080 });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.y = HOUSE_HEIGHT + ROOF_HEIGHT / 2;
                houseGroup.add(roof);

                houseGroup.position.set(x, y, z);
                return houseGroup;
            }

            // Häuser generieren um den Startpunkt der Rakete
            for (let i = 0; i < NUM_HOUSES; i++) {
                const angle = (i / NUM_HOUSES) * Math.PI * 2;
                const radius = CITY_RADIUS_MIN + (Math.random() * (CITY_RADIUS_MAX - CITY_RADIUS_MIN));
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const house = createHouse(x, 0, z);
                scene.add(house);
            }
            
            // Event-Listener für die Taste "0"
            window.addEventListener('keydown', (event) => {
                if (event.key === '0' || event.code === 'Numpad0') {
                    thrustActive = true;
                }
            });
            window.addEventListener('keyup', (event) => {
                if (event.key === '0' || event.code === 'Numpad0') {
                    thrustActive = false;
                }
            });

            // Responsivität: Fenstergröße anpassen
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Maus-Event-Handler für manuelle Kamera-Steuerung
        function onMouseDown(event) {
            if (event.button === 0) {
                isDragging = true;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }
        }

        function onMouseMove(event) {
            if (isDragging) {
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;
                
                currentPanAngle -= deltaX * PAN_SENSITIVITY;
                currentTiltAngle -= deltaY * TILT_SENSITIVITY;

                currentTiltAngle = Math.max(0.01, Math.min(Math.PI - 0.01, currentTiltAngle));

                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }
        }

        function onMouseUp(event) {
            if (event.button === 0) {
                isDragging = false;
            }
        }

        function onMouseWheel(event) {
            cameraDistance *= (1 + event.deltaY * ZOOM_MULTIPLIER_FACTOR);
            cameraDistance = Math.max(ROCKET_BODY_HEIGHT * 2, Math.min(30000000, cameraDistance));
        }

        function animate() {
            requestAnimationFrame(animate);

            // Raketen-Physik aktualisieren, NUR WENN der Slider NICHT aktiv ist
            if (!sliderManualControl) {
                if (thrustActive) {
                    rocketVelocity.y += THRUST;
                } else {
                    rocketVelocity.y += GRAVITY;
                }
                rocketPosition.add(rocketVelocity);
            }
            rocket.position.copy(rocketPosition);
			
            // Rakete darf nicht unter die definierte Bodenhöhe fallen
            const groundLevel = ROCKET_HALF_BODY_HEIGHT;
            if (rocket.position.y < groundLevel) {
                rocket.position.y = groundLevel;
                rocketVelocity.y = 0;
            }

            // Wolken rotieren lassen (mit der Erde)
            if (clouds) {
                clouds.rotation.y += 0.00005;
            }

            // Manuelle Kamera-Positionierung und Ausrichtung basierend auf sphärischen Koordinaten
            camera.position.x = rocket.position.x + cameraDistance * Math.sin(currentTiltAngle) * Math.sin(currentPanAngle);
            camera.position.y = rocket.position.y + cameraDistance * Math.cos(currentTiltAngle);
            camera.position.z = rocket.position.z + cameraDistance * Math.sin(currentTiltAngle) * Math.cos(currentPanAngle);
            camera.lookAt(rocket.position);


            // Raketenposition im UI aktualisieren
            if (rocketPositionDisplay) {
                rocketPositionDisplay.textContent = `Raketenhöhe: ${(rocket.position.y - ROCKET_HALF_BODY_HEIGHT).toFixed(2)} Meter`;
            }

            // Kamera-Höhenanzeige im UI aktualisieren
            if (cameraHeightDisplay) {
                cameraHeightDisplay.textContent = `Kamerahöhe: ${camera.position.y.toFixed(2)} Meter`;
            }

            // Szene rendern
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
